      const amounts = await router.getAmountsOut(amountTokenIn, path);
      return amounts[1];
    }

    // ======== PROFIT GUARDS (THE 3 BIG ONES) ========

    // 1) üü¢ Pre-send mempool static simulation via your contract
    async function validateBeforeTrade(token, buyRouter, sellRouter, amountIn){ // üü¢ 78
      try{
        // If your contract supports callStatic on the same function name:
        const res = await contract.callStatic.executeArbitrage(
          token.address, buyRouter, sellRouter, amountIn
        );
        // Expect positive int256 profit in USDC units (define in your contract)
        return ethers.BigNumber.isBigNumber(res)
          ? res.gt(0)
          : (typeof res === "number" ? res > 0 : !!res);
      }catch(e){
        // Fallback: do two fresh router quotes right now as a quick sanity check
        try{
          const buyOut = await getAmountOutUSDCtoToken(buyRouter, token.address, amountIn);
          const sellOut = await getAmountOutTokenToUSDC(sellRouter, token.address, buyOut);
          return sellOut.gt(amountIn);
        }catch{
          return false;
        }
      }
    }

    // 2) üü¢ Deduct estimated gas **in USDC** before allowing trade
    async function adjustForGasUSDC(token, buyRouter, sellRouter, amountIn){ // üü¢ 79
      // Build a populated tx and estimate gas; then convert native gas to USDC via on-chain price
      try{
        const populated = await contract.populateTransaction.executeArbitrage(
          token.address, buyRouter, sellRouter, amountIn
        );
        // Estimate gas
        const estGas = await signer.estimateGas({
          to: CONTRACT_ADDRESS,
          from: walletAddress,
          data: populated.data,
          value: 0
        });
        // Get gas price / EIP-1559 fields
        const feeData = await provider.getFeeData();
        // Prefer maxFeePerGas if present; else use gasPrice
        const gasPrice = feeData.maxFeePerGas || feeData.gasPrice;
        if(!gasPrice) return { gasUSDC: 0, gasInfo: "noGasPrice" };

        const nativeCostWei = estGas.mul(gasPrice);

        // Convert native (MATIC/ETH) to USDC using a router quote: 1 native -> USDC
        const native1 = ethers.utils.parseEther("1");
        const routerAny = Object.values(routers)[0];
        const router = new ethers.Contract(routerAny, ROUTER_ABI, provider);
        const nativeToUSDC = await router.getAmountsOut(native1, [WETH.address, USDC.address]);
        const usdcPerNative = parseFloat(ethers.utils.formatUnits(nativeToUSDC[1], USDC.decimals)); // USDC per 1 native
        const nativeCost = parseFloat(ethers.utils.formatEther(nativeCostWei)); // in native
        const gasUSDC = nativeCost * usdcPerNative;

        return { gasUSDC, gasInfo: `gas=${estGas.toString()} price=${ethers.utils.formatUnits(gasPrice,"gwei")} gwei` };
      }catch(e){
        log("Gas estimate failed: "+e.message,"warn");
        return { gasUSDC: 0, gasInfo: "estimateFailed" };
      }
    }

    // 3) üü¢ Private/Protect submission (UI + warnings)
    function warnIfNotPrivateRPC(){ // üü¢ 80
      // We can‚Äôt reliably read the wallet‚Äôs RPC endpoint from the injected provider.
      // Show an instructional warning if the user toggles "Use Private/Protect RPC".
      const usePrivate = document.getElementById("usePrivateTx").checked;
      const hint = document.getElementById("privateHint");
      if(usePrivate){
        hint.innerHTML = "Private mode ON. Ensure your wallet network RPC is set to a Protect/private endpoint; otherwise this will still go public mempool.";
      }else{
        hint.innerHTML = "Tip: For true private submission, set your wallet‚Äôs RPC to a Protect/private endpoint. This UI will warn if not detected.";
      }
    }

    document.getElementById("usePrivateTx").addEventListener("change", warnIfNotPrivateRPC); // üü¢ 81

    // ======== GUARDED TRADE FLOW ========

    async function guardedTrade({token, buyRouter, sellRouter, amountIn, symbol, ui}){ // üü¢ 82
      try{
        // A) Fresh slippage-adjusted profitability re-check via quotes
        const minProfitPct = parseFloat(document.getElementById("minProfitPct").value || "0");
        const slippagePct = parseFloat(document.getElementById("slippagePct").value || "0");
        const tradeAmount = parseFloat(document.getElementById("tradeAmount").value || "0");
        const slipFactor = Math.max(0, 1 - (slippagePct/100));

        const buyOut = await getAmountOutUSDCtoToken(buyRouter, token.address, amountIn);
        const sellOut = await getAmountOutTokenToUSDC(sellRouter, token.address, buyOut);
        const usdcBack = parseFloat(ethers.utils.formatUnits(sellOut, USDC.decimals));
        const profit = (usdcBack - tradeAmount) * slipFactor;
        const profitPct = (profit / tradeAmount) * 100;

        if(!(profitPct > minProfitPct)){
          log(`‚ùå Opportunity no longer meets min profit (${fmt(profitPct,2)}% < ${fmt(minProfitPct,2)}%)`);
          return;
        }

        // B) Pre-send mempool callStatic with EXACT args
        const stillValid = await validateBeforeTrade(token, buyRouter, sellRouter, amountIn);
        if(!stillValid){
          log("‚ùå Pre-send simulation indicates no profit (callStatic) ‚Äî aborting");
          return;
        }

        // C) Deduct estimated gas cost in USDC; require net > 0
        const { gasUSDC, gasInfo } = await adjustForGasUSDC(token, buyRouter, sellRouter, amountIn);
        const netProfitUSDC = profit - gasUSDC;
        if(!(netProfitUSDC > 0)){
          log(`‚õΩ Gas (${fmt(gasUSDC,6)} USDC; ${gasInfo}) would erase profit (${fmt(profit,6)} USDC) ‚Äî skipping`);
          return;
        }

        // D) Send tx; if user enabled private mode, we warn user to ensure Protect RPC
        const usePrivate = document.getElementById("usePrivateTx").checked;
        if(usePrivate){
          log("üîí Private mode: ensure your wallet RPC is a Protect/private endpoint.","warn");
        }

        // Populate and send
        const populated = await contract.populateTransaction.executeArbitrage(
          token.address, buyRouter, sellRouter, amountIn
        );

        // Try to set eip-1559 fields if available
        const feeData = await provider.getFeeData();
        if(feeData.maxPriorityFeePerGas) populated.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
        if(feeData.maxFeePerGas)        populated.maxFeePerGas        = feeData.maxFeePerGas;

        const tx = await signer.sendTransaction(populated);
        log(`üì§ Submitted tx: ${tx.hash} | ${symbol} ${ui.buyName}‚Üí${ui.sellName} | estGasUSDC=${fmt(gasUSDC,6)}`);
        const rec = await tx.wait();
        log(`‚úÖ Trade mined in block ${rec.blockNumber} ‚Äî refreshing balances`,"good");
        await refreshBalances();

      }catch(e){
        log("Trade failed: "+e.message,"bad");
      }
    }

    // ======== HELPERS ========

    window.addEventListener("load", ()=>{
      // üü¢ 83: On load, try to show initial chain hint
      if(window.ethereum){
        provider = new ethers.providers.Web3Provider(window.ethereum);
        provider.getNetwork().then(net=>{
          document.getElementById("chainLabel").textContent = `${net.name || "chain"} (id ${net.chainId})`;
        }).catch(()=>{});
      }
    });

  </script>
</body>
</html>
